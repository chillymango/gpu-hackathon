<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGPU Matrix Multiplication</title>
</head>
<body>
  <script type="module">
    async function runMatrixMultiplication() {
      if (!navigator.gpu) {
        console.error("WebGPU is not supported on this browser.");
        return;
      }

      // Request the GPU adapter and device.
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      // Define matrix dimensions.
      const N = 4; // using a 4x4 matrix as an example
      const matrixSize = N * N;
      const matrixByteSize = matrixSize * Float32Array.BYTES_PER_ELEMENT;

      // Create input matrices (for testing, we fill them with sample numbers).
      const matrixAData = new Float32Array(matrixSize);
      const matrixBData = new Float32Array(matrixSize);
      for (let i = 0; i < matrixSize; i++) {
        matrixAData[i] = i + 1;              // matrix A: [1, 2, 3, ...]
        matrixBData[i] = i + 1;        // matrix B: repeating pattern [1, 2, 3, 4, ...]
      }
      console.log(matrixAData)
      console.log(matrixBData)

      // Create GPU buffers for the matrices.
      const matrixABuffer = device.createBuffer({
        size: matrixByteSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true,
      });
      new Float32Array(matrixABuffer.getMappedRange()).set(matrixAData);
      matrixABuffer.unmap();

      const matrixBBuffer = device.createBuffer({
        size: matrixByteSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true,
      });
      new Float32Array(matrixBBuffer.getMappedRange()).set(matrixBData);
      matrixBBuffer.unmap();

      // The result (output) matrix buffer.
      const matrixCBuffer = device.createBuffer({
        size: matrixByteSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      });

      // Create a uniform buffer to hold the matrix dimension (as a 32-bit unsigned int).
      const uniformBuffer = device.createBuffer({
        size: 4, // 4 bytes for a u32
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([N]));

      // Load shader from external file "mm.wgsl"
      const shaderResponse = await fetch('mm.wgsl');
      const shaderCode = await shaderResponse.text();

      // Create the shader module.
      const shaderModule = device.createShaderModule({ code: shaderCode });

      // Create the compute pipeline.
      const computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: shaderModule,
          entryPoint: 'main'
        }
      });

      // Create a bind group that links buffers with the shader.
      const bindGroup = device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: matrixABuffer } },
          { binding: 1, resource: { buffer: matrixBBuffer } },
          { binding: 2, resource: { buffer: matrixCBuffer } },
          { binding: 3, resource: { buffer: uniformBuffer } }
        ]
      });

      // Encode commands to run the compute shader.
      const commandEncoder = device.createCommandEncoder();
      const passEncoder = commandEncoder.beginComputePass();
      passEncoder.setPipeline(computePipeline);
      passEncoder.setBindGroup(0, bindGroup);
      // Calculate workgroup count based on matrix size and workgroup size (16x16).
      const workgroupCountX = Math.ceil(N / 16);
      const workgroupCountY = Math.ceil(N / 16);
      passEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY);
      passEncoder.end();
      device.queue.submit([commandEncoder.finish()]);

      // To read back the results, copy the output buffer to a mappable read buffer.
      const readBuffer = device.createBuffer({
        size: matrixByteSize,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
      });

      const readEncoder = device.createCommandEncoder();
      readEncoder.copyBufferToBuffer(matrixCBuffer, 0, readBuffer, 0, matrixByteSize);
      device.queue.submit([readEncoder.finish()]);

      // Wait for the GPU to complete execution and map the read buffer.
      await readBuffer.mapAsync(GPUMapMode.READ);
      const arrayBuffer = readBuffer.getMappedRange();
      const resultArray = new Float32Array(arrayBuffer.slice(0));
      console.log("Result matrix:", resultArray);
      readBuffer.unmap();
    }

    runMatrixMultiplication();
  </script>
</body>
</html>
